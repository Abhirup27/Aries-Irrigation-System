//include packages if required
const fs = require('fs')
//var execute = require('../scripts/rpi-tasks.JS')
var spawn = require("child_process").spawn; 



//---main program---//
class Job{
    constructor(type, occur,time,date){
        this.jobType=type;
        this.occur= occur;
        this.time=time;
        this.date=date;
        this.done=-1;
    }
     gettime()
    {
        return this.time;
    }
    status()
    {
      switch(this.done)
      {
        case -1:
          return "false"
          break;
        case 0:
          return "running"
          break;
        case 1:
          return "done"
          break;
        default:
          return "error"
          break;
      }
}
}
var jobs = []
var done=0;
class routine{
    constructor()
    {
        this.items =
        []
        this.headIndex = 0;
         this.tailIndex = 0;
         this.i=0;
         this.smallestI;
         this.temp ={}
    }
     enqueue(Job) {
      this.items[this.tailIndex] = Job;
      this.tailIndex++;
    }
    dequeue() {
      const item = this.items[this.headIndex];
      delete this.items[this.headIndex];
      this.headIndex++;
      return item;
    }
    peek() {
      return this.items[this.headIndex];
    }
    peekJob()
    {
      return this.items[this.headIndex].jobType;
    }
    sort() {
      this.smallestI=1;
      
      for(this.i=this.headIndex; this.i<this.items.length; this.i++)
      {
        //console.log("running")
        if(this.items[this.i].time < this.items[this.smallestI].time)
        {
          
          this.smallestI= this.i;
        }
      }

      this.temp = this.items[this.headIndex]
      this.items[this.headIndex] = this.items[this.smallestI]
      this.items[this.smallestI]= this.temp;
      //const timeLeftNextTask= (this.items[0].time.slice(0,2) - currtime.slice(0,2))*60*60 +(this.items[0].time.slice(3,5) - currtime.slice(3,5))*60  -currtime.slice(6,8);
      
    }
    calcNextTaskTime(currtime){
      const timeLeftNextTask= (this.items[this.headIndex].time.slice(0,2) - currtime.slice(0,2))*60*60 +(this.items[this.headIndex].time.slice(3,5) - currtime.slice(3,5))*60  -currtime.slice(6,8);
      return timeLeftNextTask;
    }
    get length() {
      return this.tailIndex - this.headIndex;
    }

}
const routines = new routine();
//routines.enqueue(jobs[0]);


  //convert time  forom 24 hour format to seconds before passing time
  function runTask(cb, time) 
  //cb is callback function which is the next task that has to be run time in seconds
  {
    setTimeout(cb,time*1000)

  }

  module.exports = {
    restartSchedule: function (date ,time) {
	console.log("start of restart sche")
      jobs=[]
      fs.readFile("./data/jobSchedule.JSON", 'utf-8', (err, Rdata)=>
    {
        if(err){
            throw err;
        }

        //console.log(Object.values(JSON.parse(Rdata)))
        const data = JSON.parse(Rdata)//JSON.parse(Rdata.toString());
        //console.log(data)
        var i;
        for(i=0; i<data.length; i++)
          {
            jobs.push(new Job(data[i].jobType, data[i].occur,data[i].time,data[i].date))
           console.log(jobs[i])
          }
          for(i=0;i<jobs.length; i++)
          {
           console.log(date)
            if(jobs[i].date == date)
            {
              //console.log(jobs[i]);
		console.log('inside if or restart Sche')              
              routines.enqueue(jobs[i])
              
              //console.log(routines.items[1]);
              
            }
          }
          if(routines.length ==0){return}
          if(routines.length >1){
	console.log('before sorting')            
          routines.sort()
          }
	var process
         const timeLeft=  routines.calcNextTaskTime(time);
		console.log(timeLeft)
	if(timeLeft <0)
		{
		//done=  execute.execTask(routines.items[routines.headIndex].jobType);
	      // process = spawn('python',["./scripts/GPIOtasks.pyw"] );
		}
		else{
			//setTimeout(function(){done=  execute.execTask(routines.items[routines.headIndex].jobType)},timeLeft*1000)		
		//	setTimeout(function(){ process = spawn('python',["./scripts/GPIOtasks.pyw"] );},timeLeft*1000)
		}          
   		if(process==1){console.log("Task is done!")}
	 }
     )  
    },

    setDate: function(D){
      console.log(D);
    },
    getjobTypeTop: function()
    {
      return routines.peek();  
    },
   calcTimeLeft: function(time)
	{
	timeLeft =routines.calcNextTaskTime(time);
	return timeLeft;
	}
  };

